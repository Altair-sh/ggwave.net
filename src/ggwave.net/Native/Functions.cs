using System;
using System.Runtime.InteropServices;

namespace ggwave.net.Native;

// GGWave instances are identified with an integer and are stored
// in a private map container. Using VoidPtr caused some issues with
// the python module and unfortunately had to do it this way
using ggwave_Instance = int;
using VoidPtr = IntPtr;
using ConstVoidPtr = IntPtr;

internal static class Functions
{
    /// Change file stream for internal ggwave logging.
    /// NOTICE: Not thread-safe. Do not call while any GGWave instances are running
    ///
    /// file_ptr - C FILE pointer
    /// 
    ///   Log to standard error
    ///   ggwave_setLogFile(stderr);
    /// 
    ///   Log to standard output
    ///   ggwave_setLogFile(stdout);
    /// 
    ///   Disable logging
    ///   ggwave_setLogFile(NULL);
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern void ggwave_setLogFile(VoidPtr file_ptr);

    /// Helper method to get default instance parameters
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern GGWaveParameters ggwave_getDefaultParameters();

    /// Create a new GGWave instance with the specified parameters
    /// 
    /// The newly created instance is added to the internal map container.
    /// This function returns an id that can be used to identify this instance.
    /// Make sure to deallocate the instance at the end by calling ggwave_free()
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern ggwave_Instance ggwave_init(GGWaveParameters parameters);

    /// Free a GGWave instance
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern void ggwave_free(ggwave_Instance instance);

    /// Encode data into audio waveform
    ///   instance       - the GGWave instance to use
    ///   payloadBuffer  - the data to encode
    ///   payloadSize    - number of bytes in the input payloadBuffer
    ///   protocolId     - the protocol to use for encoding
    ///   volume         - the volume of the generated waveform [0, 100]
    ///                    usually 25 is OK and you should not go over 50
    ///   waveformBuffer - the generated audio waveform. must be big enough to fit the generated data
    ///   query          - if == 0, encode data in to waveformBuffer, returns number of bytes
    ///                    if != 0, do not perform encoding.
    ///                    if == 1, return waveform size in bytes
    ///                    if != 1, return waveform size in samples
    /// 
    ///   returns the number of generated bytes or samples (see query)
    ///   returns -1 if there was an error
    ///   This function can be used to encode some binary data (payload) into an audio waveform.
    ///     payload -> waveform
    /// 
    ///   When calling it, make sure that the waveformBuffer is big enough to store the
    ///   generated waveform. This means that its size must be at least:
    ///     nSamples*sizeOfSample_bytes
    /// 
    ///   Where nSamples is the number of audio samples in the waveform and sizeOfSample_bytes
    ///   is the size of a single sample in bytes based on the sampleFormatOut parameter
    ///   specified during the initialization of the GGWave instance.
    /// 
    ///   If query != 0, then this function does not perform the actual encoding and just
    ///   outputs the expected size of the waveform that would be generated if you call it
    ///   with query == 0. This mechanism can be used to ask ggwave how much memory to
    ///   allocate for the waveformBuffer. For example:
    /// 
    ///     this is the data to encode
    ///     const char * payload = "test";
    /// 
    ///     query the number of bytes in the waveform
    ///     int n = ggwave_encode(instance, payload, 4, GGWAVE_PROTOCOL_AUDIBLE_FAST, 25, NULL, 1);
    /// 
    ///     allocate the output buffer
    ///     char waveform[n];
    /// 
    ///     generate the waveform
    ///     ggwave_encode(instance, payload, 4, GGWAVE_PROTOCOL_AUDIBLE_FAST, 25, waveform, 0);
    /// 
    ///   The payloadBuffer can be any binary data that you would like to transmit (i.e. the payload).
    ///   Usually, this is some text, but it can be any sequence of bytes.
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern int ggwave_encode(
        ggwave_Instance instance,
        ConstVoidPtr payloadBuffer,
        int payloadSize,
        GGWaveProtocolId protocolId,
        int volume,
        VoidPtr waveformBuffer,
        int query);

    /// Decode an audio waveform into data
    /// 
    ///   instance       - the GGWave instance to use
    ///   waveformBuffer - the audio waveform
    ///   waveformSize   - number of bytes in the input waveformBuffer
    ///   payloadBuffer  - stores the decoded data on success
    ///                    the maximum size of the output is GGWave::kMaxDataSize
    /// 
    ///   returns the number of decoded bytes
    /// 
    ///   Use this function to continuously provide audio samples to a GGWave instance.
    ///   On each call, GGWave will analyze the provided data and if it detects a payload,
    ///   it will return a non-zero result.
    ///     waveform -> payload
    /// 
    ///   If the return value is -1 then there was an error during the decoding process.
    ///   Usually can occur if there is a lot of background noise in the audio.
    ///   If the return value is greater than 0, then there are that number of bytes decoded.
    /// 
    ///   IMPORTANT:
    ///   Notice that the decoded data written to the payloadBuffer is NOT null terminated.
    /// 
    ///   Example:
    ///     char payload[256];
    ///     while (true) {
    ///         ... capture samplesPerFrame audio samples into waveform ...
    ///         int ret = ggwave_decode(instance, waveform, samplesPerFrame*sizeOfSample_bytes, payload);
    ///         if (ret > 0) {
    ///             payload[ret] = 0; /// null terminate the string
    ///             printf("Received payload: '%s'\n", payload);
    ///         }
    ///     }
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern int ggwave_decode(
        ggwave_Instance instance,
        ConstVoidPtr waveformBuffer,
        int waveformSize,
        VoidPtr payloadBuffer);

    /// Memory-safe overload of ggwave_decode
    /// 
    ///   payloadSize - optionally specify the size of the output buffer
    /// 
    ///   If the return value is -2 then the provided payloadBuffer was not big enough to
    ///   store the decoded data.
    ///   See ggwave_decode for more information
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern int ggwave_ndecode(
        ggwave_Instance instance,
        ConstVoidPtr waveformBuffer,
        int waveformSize,
        VoidPtr payloadBuffer,
        int payloadSize);

    /// Toggle Rx protocols on and off
    /// 
    ///   protocolId - Id of the Rx protocol to modify
    ///   state      - 0 - disable, 1 - enable
    /// 
    ///   If an Rx protocol is enabled, newly constructued GGWave instances will attempt to decode
    ///   received data using this protocol. By default, all protocols are enabled.
    ///   Use this function to restrict the number of Rx protocols used in the decoding
    ///   process. This helps to reduce the number of false positives and improves the transmission
    ///   accuracy, especially when the Tx/Rx protocol is known in advance.
    /// 
    ///   Note that this function does not affect the decoding process of instances that have
    ///   already been created.
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern void ggwave_rxToggleProtocol(
        GGWaveProtocolId protocolId,
        int state);

    /// Toggle Tx protocols on and off
    /// 
    ///   protocolId - Id of the Tx protocol to modify
    ///   state      - 0 - disable, 1 - enable
    /// 
    ///   If an Tx protocol is enabled, newly constructued GGWave instances will be able to transmit
    ///   data using this protocol. By default, all protocols are enabled.
    ///   Use this function to restrict the number of Tx protocols used for transmission.
    ///   This can reduce the required memory by the GGWave instance.
    /// 
    ///   Note that this function does not affect instances that have already been created.
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern void ggwave_txToggleProtocol(
        GGWaveProtocolId protocolId,
        int state);

    /// Set freqStart for an Rx protocol
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern void ggwave_rxProtocolSetFreqStart(
        GGWaveProtocolId protocolId,
        int freqStart);

    /// Set freqStart for a Tx protocol
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern void ggwave_txProtocolSetFreqStart(
        GGWaveProtocolId protocolId,
        int freqStart);

    /// Return recvDuration_frames value for a rx protocol
    [DllImport(NativeConstants.GGWaveLibName, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
    public static extern int ggwave_rxDurationFrames(
        ggwave_Instance instance);
}